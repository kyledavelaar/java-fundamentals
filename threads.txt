
One call stack per thread
  - main() method starts one thread
  - any other threads you start work concurrently with that main thread

JVMs and Threads
  - different JVMs can run threads in different ways so don't write code that only caters to one JVM.  Write thread safe code that will work in any JVM
  - for example some JVMs round robin nicely, others allow one thread to hog all the resources

daemon threads versus user threads
  - user threads are the main types of threads you will be writing
  - JVM will shut down once all user threads are done


java.lang.Thread

start()
yield()
sleep()
run()


Instantiate a thread in one of two ways:
  - Extend the java.lang.Thread class
    - won't typically do this b/c would only want to extend if want to create a subclass of behavior that builds upon the existing thread class
  - Implement the Runnable interface
    - will typically use this b/c just want to use thread behavior in your job
    - this also leaves your class able to extend another class


  class MyThreadClass extends Thread {
    public void run() {
      // put job logic here that you want run on a separate thread
      // Thread class expects no arguments passed into run
      // all code inside this method will be run in a new thread
      // also this method will be called for you when you instantiate MyThreadClass
      // there is no need to call myThreadClass.run();
      // here we are combining the job and the thread it is running on into one class
    }

    public void run(String s) {
      // overloaded method but warning!  Threads will only be used in run methods that have no arguments passed to them...so overloading here doesn't help you out much. All code here will be run on the main call stack. not a new call stack
      // you must call the overloaded method yourself
    }
  }


  class MyRunnable implements Runnable {
    public void run() {
      // put job logic here that want run on a separate thread
      // notice now the job logic is separated from the thread that will actually be used to run this job (much better)

      System.out.println("Job being run on thread " + Thread.currentThread().getName());

      for (int x = 0; int < 6; int++) {
        System.out.println("job running");
      }

      // when target run method of the thread completes, the thread is considered to be "done" and the stack for that thread dissolves
    }
  }

  public class TestThreads {
    public static void main(String[] args) {
      MyRunnable mr = new MyRunnable();
      // think of the thread as the "worker"
      // here we have one job being run by many workers
      Thread t1 = new Thread(mr);
      Thread t2 = new Thread(mr);
      Thread t3 = new Thread(mr);
      t1.setName("First Thread");

      // threads are not run in order so t2 could very easily finish or even start before t1, it is all up to the scheduler

      t1.start();  // can only call start on a Thread instance, NOT a Runnable!
      t2.start();
      t3.start();

      t1.isAlive() // logs if thread is still running
      t2.getState() // very useful for debugging

      t1.start() // NO CAN'T DO THIS -> once a thread is started, it can never be started again, even if the first run has completed
    }
  }

  Types of Thread() constructors are:
    - Thread() // used when extending Thread class
    - Thread(Runnable r) // used above when have separate runnable and thread class
    - Thread(Runnable r, String name)
    - Thread(String name)


  Thread states:
    - new
      - thread instance has been created but start() method not called yet
      - a live thread object but not a 'thread of execution'
      - thread considered 'not alive' yet
    - runnable
      - eligible to be run but scheduler has not picked it up yet
      - moves into runnable state when start() method invoked
      - can also move back into runnable state from a blocked, waiting, or sleeping state
    - running
      - scheduler chooses this thread and says, okay run now
      - run() method called and actively working on the job logic
    - waiting/blocked/sleeping
      - not eligible to run, it is alive just not runnable
      - why put in this state?  it could be waiting for resources to come available, or an object might have a lock on it
      - may be sleeping b/c the code tells the thread to sleep for a period of time
      - you can't tell another thread to sleep or wait or block it in any way
    - dead
      - run method completes
      - can never be brought back to life and executed again

  Sleep()
    - call in run() method to stop job from running for >= a set time
    - static method on the Thread class
    - Thread.sleep(5000);  // 5 seconds

  Priorities
    - can give a thread a priority from 1 to 10 and it will usually be granted but not always
    - default priority is 5
      Thread t = new Thread();
      t.setPriority(8);
      t.start();

  Yield()
    - call in run() method to stop job from running and give other jobs with higher priority a chance to run (no guarantee this will happen)

  Join()
    - lets one thread join onto the end of another thread
    - Thread B for example can't finish its work until Thread A is done so you would join B to A.  B will then run sometime after A's completion.
    - join() can cause the current thread to stop executing until the thread it joins with completes
      Thread a = new Thread(runnableJobA);
      a.start();
      Thread b = new Thread(runnableJobB);
      b.start();
      // now both thread running simultaneously if multi-core
      b.join(); // A joins to the end of B
      // B will be the only job running now...when it completes A will again resume


  Scheduler:
    - In single Processor machines only one thread can run at once.  The scheduler determines which thread will run at any one time.




















